{
  "version": 3,
  "sources": ["../../../../../node_modules/@angular/core/fesm2022/rxjs-interop.mjs", "../../../../../node_modules/ngx-lottie/fesm2022/ngx-lottie.mjs"],
  "sourcesContent": ["/**\n * @license Angular v17.3.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { assertInInjectionContext, inject, DestroyRef, ɵRuntimeError, ɵgetOutputDestroyRef, Injector, effect, untracked, assertNotInReactiveContext, signal, computed } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\n\n/**\n * Operator which completes the Observable when the calling context (component, directive, service,\n * etc) is destroyed.\n *\n * @param destroyRef optionally, the `DestroyRef` representing the current context. This can be\n *     passed explicitly to use `takeUntilDestroyed` outside of an [injection\n * context](guide/dependency-injection-context). Otherwise, the current `DestroyRef` is injected.\n *\n * @developerPreview\n */\nfunction takeUntilDestroyed(destroyRef) {\n    if (!destroyRef) {\n        assertInInjectionContext(takeUntilDestroyed);\n        destroyRef = inject(DestroyRef);\n    }\n    const destroyed$ = new Observable(observer => {\n        const unregisterFn = destroyRef.onDestroy(observer.next.bind(observer));\n        return unregisterFn;\n    });\n    return (source) => {\n        return source.pipe(takeUntil(destroyed$));\n    };\n}\n\n/**\n * Implementation of `OutputRef` that emits values from\n * an RxJS observable source.\n *\n * @internal\n */\nclass OutputFromObservableRef {\n    constructor(source) {\n        this.source = source;\n        this.destroyed = false;\n        this.destroyRef = inject(DestroyRef);\n        this.destroyRef.onDestroy(() => {\n            this.destroyed = true;\n        });\n    }\n    subscribe(callbackFn) {\n        if (this.destroyed) {\n            throw new ɵRuntimeError(953 /* ɵRuntimeErrorCode.OUTPUT_REF_DESTROYED */, ngDevMode &&\n                'Unexpected subscription to destroyed `OutputRef`. ' +\n                    'The owning directive/component is destroyed.');\n        }\n        // Stop yielding more values when the directive/component is already destroyed.\n        const subscription = this.source.pipe(takeUntilDestroyed(this.destroyRef)).subscribe({\n            next: value => callbackFn(value),\n        });\n        return {\n            unsubscribe: () => subscription.unsubscribe(),\n        };\n    }\n}\n/**\n * Declares an Angular output that is using an RxJS observable as a source\n * for events dispatched to parent subscribers.\n *\n * The behavior for an observable as source is defined as followed:\n *    1. New values are forwarded to the Angular output (next notifications).\n *    2. Errors notifications are not handled by Angular. You need to handle these manually.\n *       For example by using `catchError`.\n *    3. Completion notifications stop the output from emitting new values.\n *\n * @usageNotes\n * Initialize an output in your directive by declaring a\n * class field and initializing it with the `outputFromObservable()` function.\n *\n * ```ts\n * @Directive({..})\n * export class MyDir {\n *   nameChange$ = <some-observable>;\n *   nameChange = outputFromObservable(this.nameChange$);\n * }\n * ```\n *\n * @developerPreview\n */\nfunction outputFromObservable(observable, opts) {\n    ngDevMode && assertInInjectionContext(outputFromObservable);\n    return new OutputFromObservableRef(observable);\n}\n\n/**\n * Converts an Angular output declared via `output()` or `outputFromObservable()`\n * to an observable.\n *\n * You can subscribe to the output via `Observable.subscribe` then.\n *\n * @developerPreview\n */\nfunction outputToObservable(ref) {\n    const destroyRef = ɵgetOutputDestroyRef(ref);\n    return new Observable(observer => {\n        // Complete the observable upon directive/component destroy.\n        // Note: May be `undefined` if an `EventEmitter` is declared outside\n        // of an injection context.\n        destroyRef?.onDestroy(() => observer.complete());\n        const subscription = ref.subscribe(v => observer.next(v));\n        return () => subscription.unsubscribe();\n    });\n}\n\n/**\n * Exposes the value of an Angular `Signal` as an RxJS `Observable`.\n *\n * The signal's value will be propagated into the `Observable`'s subscribers using an `effect`.\n *\n * `toObservable` must be called in an injection context unless an injector is provided via options.\n *\n * @developerPreview\n */\nfunction toObservable(source, options) {\n    !options?.injector && assertInInjectionContext(toObservable);\n    const injector = options?.injector ?? inject(Injector);\n    const subject = new ReplaySubject(1);\n    const watcher = effect(() => {\n        let value;\n        try {\n            value = source();\n        }\n        catch (err) {\n            untracked(() => subject.error(err));\n            return;\n        }\n        untracked(() => subject.next(value));\n    }, { injector, manualCleanup: true });\n    injector.get(DestroyRef).onDestroy(() => {\n        watcher.destroy();\n        subject.complete();\n    });\n    return subject.asObservable();\n}\n\n/**\n * Get the current value of an `Observable` as a reactive `Signal`.\n *\n * `toSignal` returns a `Signal` which provides synchronous reactive access to values produced\n * by the given `Observable`, by subscribing to that `Observable`. The returned `Signal` will always\n * have the most recent value emitted by the subscription, and will throw an error if the\n * `Observable` errors.\n *\n * With `requireSync` set to `true`, `toSignal` will assert that the `Observable` produces a value\n * immediately upon subscription. No `initialValue` is needed in this case, and the returned signal\n * does not include an `undefined` type.\n *\n * By default, the subscription will be automatically cleaned up when the current [injection\n * context](/guide/dependency-injection-context) is destroyed. For example, when `toObservable` is\n * called during the construction of a component, the subscription will be cleaned up when the\n * component is destroyed. If an injection context is not available, an explicit `Injector` can be\n * passed instead.\n *\n * If the subscription should persist until the `Observable` itself completes, the `manualCleanup`\n * option can be specified instead, which disables the automatic subscription teardown. No injection\n * context is needed in this configuration as well.\n *\n * @developerPreview\n */\nfunction toSignal(source, options) {\n    ngDevMode &&\n        assertNotInReactiveContext(toSignal, 'Invoking `toSignal` causes new subscriptions every time. ' +\n            'Consider moving `toSignal` outside of the reactive context and read the signal value where needed.');\n    const requiresCleanup = !options?.manualCleanup;\n    requiresCleanup && !options?.injector && assertInInjectionContext(toSignal);\n    const cleanupRef = requiresCleanup ? options?.injector?.get(DestroyRef) ?? inject(DestroyRef) : null;\n    // Note: T is the Observable value type, and U is the initial value type. They don't have to be\n    // the same - the returned signal gives values of type `T`.\n    let state;\n    if (options?.requireSync) {\n        // Initially the signal is in a `NoValue` state.\n        state = signal({ kind: 0 /* StateKind.NoValue */ });\n    }\n    else {\n        // If an initial value was passed, use it. Otherwise, use `undefined` as the initial value.\n        state = signal({ kind: 1 /* StateKind.Value */, value: options?.initialValue });\n    }\n    // Note: This code cannot run inside a reactive context (see assertion above). If we'd support\n    // this, we would subscribe to the observable outside of the current reactive context, avoiding\n    // that side-effect signal reads/writes are attribute to the current consumer. The current\n    // consumer only needs to be notified when the `state` signal changes through the observable\n    // subscription. Additional context (related to async pipe):\n    // https://github.com/angular/angular/pull/50522.\n    const sub = source.subscribe({\n        next: value => state.set({ kind: 1 /* StateKind.Value */, value }),\n        error: error => {\n            if (options?.rejectErrors) {\n                // Kick the error back to RxJS. It will be caught and rethrown in a macrotask, which causes\n                // the error to end up as an uncaught exception.\n                throw error;\n            }\n            state.set({ kind: 2 /* StateKind.Error */, error });\n        },\n        // Completion of the Observable is meaningless to the signal. Signals don't have a concept of\n        // \"complete\".\n    });\n    if (ngDevMode && options?.requireSync && state().kind === 0 /* StateKind.NoValue */) {\n        throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n    }\n    // Unsubscribe when the current context is destroyed, if requested.\n    cleanupRef?.onDestroy(sub.unsubscribe.bind(sub));\n    // The actual returned signal is a `computed` of the `State` signal, which maps the various states\n    // to either values or errors.\n    return computed(() => {\n        const current = state();\n        switch (current.kind) {\n            case 1 /* StateKind.Value */:\n                return current.value;\n            case 2 /* StateKind.Error */:\n                throw current.error;\n            case 0 /* StateKind.NoValue */:\n                // This shouldn't really happen because the error is thrown on creation.\n                // TODO(alxhub): use a RuntimeError when we finalize the error semantics\n                throw new ɵRuntimeError(601 /* ɵRuntimeErrorCode.REQUIRE_SYNC_WITHOUT_SYNC_EMIT */, '`toSignal()` called with `requireSync` but `Observable` did not emit synchronously.');\n        }\n    });\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { outputFromObservable, outputToObservable, takeUntilDestroyed, toObservable, toSignal };\n\n", "import * as i0 from '@angular/core';\nimport { InjectionToken, inject, NgZone, ɵisPromise as _isPromise, Injectable, input, PLATFORM_ID, Directive, Output, ElementRef, Component, ChangeDetectionStrategy, ViewChild, makeStateKey } from '@angular/core';\nimport { from, of, Observable, Subject, BehaviorSubject, defer } from 'rxjs';\nimport { map, tap, shareReplay, mergeMap, filter, switchMap } from 'rxjs/operators';\nimport { isPlatformBrowser, NgStyle, NgClass } from '@angular/common';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nconst _c0 = [\"container\"];\nconst LOTTIE_OPTIONS = new InjectionToken('LottieOptions');\nfunction convertPlayerOrLoaderToObservable() {\n  const ngZone = inject(NgZone);\n  const {\n    player,\n    useWebWorker\n  } = inject(LOTTIE_OPTIONS);\n  const playerOrLoader = ngZone.runOutsideAngular(() => player());\n  // We need to use `isPromise` instead of checking whether\n  // `result instanceof Promise`. In zone.js patched environments, `global.Promise`\n  // is the `ZoneAwarePromise`. Some APIs, which are likely not patched by zone.js\n  // for certain reasons, might not work with `instanceof`. For instance, the dynamic\n  // import `() => import('./chunk.js')` returns a native promise (not a `ZoneAwarePromise`),\n  // causing this check to be falsy.\n  const player$ = _isPromise(playerOrLoader) ? from(playerOrLoader).pipe(map(module => module.default || module)) : of(playerOrLoader);\n  return player$.pipe(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  tap(player => player.useWebWorker?.(useWebWorker)), shareReplay({\n    bufferSize: 1,\n    refCount: true\n  }));\n}\nclass AnimationLoader {\n  constructor() {\n    this.player$ = convertPlayerOrLoaderToObservable().pipe(mergeMap(player => raf$(this.ngZone).pipe(map(() => player))));\n    this.ngZone = inject(NgZone);\n  }\n  loadAnimation(options) {\n    return this.player$.pipe(map(player => this.createAnimationItem(player, options)));\n  }\n  resolveOptions(options, container) {\n    return Object.assign({\n      container,\n      renderer: 'svg',\n      loop: true,\n      autoplay: true\n    }, options);\n  }\n  createAnimationItem(player, options) {\n    return this.ngZone.runOutsideAngular(() => player.loadAnimation(options));\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function AnimationLoader_Factory(t) {\n      return new (t || AnimationLoader)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: AnimationLoader,\n      factory: AnimationLoader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(AnimationLoader, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nfunction raf$(ngZone) {\n  return new Observable(subscriber => {\n    const requestId = ngZone.runOutsideAngular(() => requestAnimationFrame(() => {\n      subscriber.next();\n      subscriber.complete();\n    }));\n    return () => cancelAnimationFrame(requestId);\n  });\n}\nclass CacheableAnimationLoader extends AnimationLoader {\n  constructor() {\n    super(...arguments);\n    this.cache = new Map();\n  }\n  ngOnDestroy() {\n    this.cache.clear();\n  }\n  loadAnimation(options) {\n    return this.player$.pipe(map(player => {\n      const animationItem = this.createAnimationItem(player, this.transformOptions(options));\n      this.awaitConfigAndCache(options, animationItem);\n      return animationItem;\n    }));\n  }\n  awaitConfigAndCache(options, animationItem) {\n    if (this.isAnimationConfigWithPath(options)) {\n      // Don't wait for the `config_ready` event if it has been cached previously.\n      if (this.cache.has(options.path)) {\n        return;\n      }\n      animationItem.addEventListener('config_ready', () => {\n        // See the comments below on why we're storing the animation data as a string.\n        this.cache.set(options.path, JSON.stringify(animationItem['animationData']));\n      });\n    }\n  }\n  transformOptions(options) {\n    if (this.isAnimationConfigWithPath(options) && this.cache.has(options.path)) {\n      return {\n        ...options,\n        path: undefined,\n        // Caretaker note: `lottie-web` cannot re-use the `animationData` object between animations, and we\n        // have to retrieve a new object each time an animation is created.\n        // https://github.com/airbnb/lottie-web#html\n        // See comments for the `animationData` property.\n        animationData: JSON.parse(this.cache.get(options.path))\n      };\n    } else {\n      return options;\n    }\n  }\n  isAnimationConfigWithPath(options) {\n    return typeof options.path === 'string';\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵCacheableAnimationLoader_BaseFactory;\n      return function CacheableAnimationLoader_Factory(t) {\n        return (ɵCacheableAnimationLoader_BaseFactory || (ɵCacheableAnimationLoader_BaseFactory = i0.ɵɵgetInheritedFactory(CacheableAnimationLoader)))(t || CacheableAnimationLoader);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: CacheableAnimationLoader,\n      factory: CacheableAnimationLoader.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(CacheableAnimationLoader, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], null, null);\n})();\nfunction provideCacheableAnimationLoader() {\n  return [{\n    provide: AnimationLoader,\n    useExisting: CacheableAnimationLoader\n  }];\n}\nfunction provideLottieOptions(options) {\n  return [{\n    provide: LOTTIE_OPTIONS,\n    useValue: options\n  }];\n}\nclass BaseDirective {\n  constructor() {\n    this.options = input(null);\n    this.containerClass = input(null);\n    this.styles = input(null);\n    /**\n     * `animationCreated` is dispatched after calling `loadAnimation`.\n     */\n    this.animationCreated = this.getAnimationItem();\n    /**\n     * `complete` is dispatched after completing the last frame.\n     */\n    this.complete = this.awaitAnimationItemAndStartListening('complete');\n    /**\n     * `loopComplete` is dispatched after completing the frame loop.\n     */\n    this.loopComplete = this.awaitAnimationItemAndStartListening('loopComplete');\n    /**\n     * `enterFrame` is dispatched after entering the new frame.\n     */\n    this.enterFrame = this.awaitAnimationItemAndStartListening('enterFrame');\n    /**\n     * `segmentStart` is dispatched when the new segment is adjusted.\n     */\n    this.segmentStart = this.awaitAnimationItemAndStartListening('segmentStart');\n    /**\n     * Original event name is `config_ready`. `config_ready` is dispatched\n     * after the needed renderer is configured.\n     */\n    this.configReady = this.awaitAnimationItemAndStartListening('config_ready');\n    /**\n     * Original event name is `data_ready`. `data_ready` is dispatched\n     * when all parts of the animation have been loaded.\n     */\n    this.dataReady = this.awaitAnimationItemAndStartListening('data_ready');\n    /**\n     * Original event name is `DOMLoaded`. `DOMLoaded` is dispatched\n     * when elements have been added to the DOM.\n     */\n    this.domLoaded = this.awaitAnimationItemAndStartListening('DOMLoaded');\n    /**\n     * `destroy` will be dispatched when the component gets destroyed,\n     * it's handy for releasing resources.\n     */\n    this.destroy = this.awaitAnimationItemAndStartListening('destroy');\n    /**\n     * `error` will be dispatched if the Lottie player could not render\n     * some frame or parse config.\n     */\n    this.error = this.awaitAnimationItemAndStartListening('error');\n    this.ngZone = inject(NgZone);\n    this.isBrowser = isPlatformBrowser(inject(PLATFORM_ID));\n    this.animationLoader = inject(AnimationLoader);\n    this.loadAnimation$ = new Subject();\n    this.animationItem$ = new BehaviorSubject(null);\n    this.setupLoadAnimationListener();\n  }\n  ngOnDestroy() {\n    this.destroyAnimation();\n  }\n  loadAnimation(changes, container) {\n    this.ngZone.runOutsideAngular(() => this.loadAnimation$.next([changes, container]));\n  }\n  getAnimationItem() {\n    return defer(() => this.animationItem$).pipe(filter(animationItem => animationItem !== null));\n  }\n  awaitAnimationItemAndStartListening(name) {\n    return this.getAnimationItem().pipe(switchMap(animationItem =>\n    // `fromEvent` will try to call `removeEventListener` when `unsubscribe()` is invoked.\n    // The problem is that `ngOnDestroy()` is called before Angular unsubscribes from\n    // `@Output()` properties, thus `animationItem` will be `null` already, also `lottie-web`\n    // removes event listeners when calling `destroy()`.\n    new Observable(observer => {\n      this.ngZone.runOutsideAngular(() => {\n        animationItem.addEventListener(name, event => {\n          this.ngZone.runOutsideAngular(() => {\n            observer.next(event);\n          });\n        });\n      });\n    })));\n  }\n  setupLoadAnimationListener() {\n    const loadAnimation$ = this.loadAnimation$.pipe(filter(([changes]) => this.isBrowser && changes.options !== undefined));\n    loadAnimation$.pipe(switchMap(([changes, container]) => {\n      this.destroyAnimation();\n      return this.animationLoader.loadAnimation(this.animationLoader.resolveOptions(changes.options.currentValue, container));\n    }), takeUntilDestroyed()).subscribe(animationItem => {\n      this.ngZone.run(() => this.animationItem$.next(animationItem));\n    });\n  }\n  destroyAnimation() {\n    const animationItem = this.animationItem$.getValue();\n    // The `ng-lottie` component or the `lottie` directive can be destroyed\n    // before the `animationItem` is set, thus it will fail with\n    // `Cannot read property 'destroy' of null`.\n    // Potentially it can happen if the directive gets destroyed before change\n    // detection is run.\n    if (animationItem === null) {\n      return;\n    }\n    // `destroy()` will remove all events listeners.\n    animationItem.destroy();\n    this.animationItem$.next(null);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function BaseDirective_Factory(t) {\n      return new (t || BaseDirective)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: BaseDirective,\n      selectors: [[\"\", \"lottie\", \"\"]],\n      inputs: {\n        options: [i0.ɵɵInputFlags.SignalBased, \"options\"],\n        containerClass: [i0.ɵɵInputFlags.SignalBased, \"containerClass\"],\n        styles: [i0.ɵɵInputFlags.SignalBased, \"styles\"]\n      },\n      outputs: {\n        animationCreated: \"animationCreated\",\n        complete: \"complete\",\n        loopComplete: \"loopComplete\",\n        enterFrame: \"enterFrame\",\n        segmentStart: \"segmentStart\",\n        configReady: \"configReady\",\n        dataReady: \"dataReady\",\n        domLoaded: \"domLoaded\",\n        destroy: \"destroy\",\n        error: \"error\"\n      }\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(BaseDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[lottie]'\n    }]\n  }], () => [], {\n    animationCreated: [{\n      type: Output\n    }],\n    complete: [{\n      type: Output\n    }],\n    loopComplete: [{\n      type: Output\n    }],\n    enterFrame: [{\n      type: Output\n    }],\n    segmentStart: [{\n      type: Output\n    }],\n    configReady: [{\n      type: Output\n    }],\n    dataReady: [{\n      type: Output\n    }],\n    domLoaded: [{\n      type: Output\n    }],\n    destroy: [{\n      type: Output\n    }],\n    error: [{\n      type: Output\n    }]\n  });\n})();\nclass LottieDirective extends BaseDirective {\n  constructor() {\n    super(...arguments);\n    this.host = inject(ElementRef);\n  }\n  ngOnChanges(changes) {\n    super.loadAnimation(changes, this.host.nativeElement);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵLottieDirective_BaseFactory;\n      return function LottieDirective_Factory(t) {\n        return (ɵLottieDirective_BaseFactory || (ɵLottieDirective_BaseFactory = i0.ɵɵgetInheritedFactory(LottieDirective)))(t || LottieDirective);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: LottieDirective,\n      selectors: [[\"\", \"lottie\", \"\"]],\n      standalone: true,\n      features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LottieDirective, [{\n    type: Directive,\n    args: [{\n      selector: '[lottie]',\n      standalone: true\n    }]\n  }], null, null);\n})();\nclass LottieComponent extends BaseDirective {\n  constructor() {\n    super(...arguments);\n    this.width = input(null);\n    this.height = input(null);\n    this.container = null;\n  }\n  ngOnChanges(changes) {\n    super.loadAnimation(changes, this.container.nativeElement);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = /* @__PURE__ */(() => {\n      let ɵLottieComponent_BaseFactory;\n      return function LottieComponent_Factory(t) {\n        return (ɵLottieComponent_BaseFactory || (ɵLottieComponent_BaseFactory = i0.ɵɵgetInheritedFactory(LottieComponent)))(t || LottieComponent);\n      };\n    })();\n  }\n  /** @nocollapse */\n  static {\n    this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: LottieComponent,\n      selectors: [[\"ng-lottie\"]],\n      viewQuery: function LottieComponent_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c0, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);\n        }\n      },\n      inputs: {\n        width: [i0.ɵɵInputFlags.SignalBased, \"width\"],\n        height: [i0.ɵɵInputFlags.SignalBased, \"height\"]\n      },\n      standalone: true,\n      features: [i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n      decls: 2,\n      vars: 6,\n      consts: [[\"container\", \"\"], [3, \"ngStyle\", \"ngClass\"]],\n      template: function LottieComponent_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelement(0, \"div\", 1, 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵstyleProp(\"width\", ctx.width() || \"100%\")(\"height\", ctx.height() || \"100%\");\n          i0.ɵɵproperty(\"ngStyle\", ctx.styles())(\"ngClass\", ctx.containerClass());\n        }\n      },\n      dependencies: [NgStyle, NgClass],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LottieComponent, [{\n    type: Component,\n    args: [{\n      selector: 'ng-lottie',\n      template: `\n    <div\n      #container\n      [style.width]=\"width() || '100%'\"\n      [style.height]=\"height() || '100%'\"\n      [ngStyle]=\"styles()\"\n      [ngClass]=\"containerClass()\"\n    ></div>\n  `,\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      standalone: true,\n      imports: [NgStyle, NgClass]\n    }]\n  }], null, {\n    container: [{\n      type: ViewChild,\n      args: ['container', {\n        static: true\n      }]\n    }]\n  });\n})();\nfunction transformAnimationFilenameToKey(animation) {\n  const [animationName] = animation.split('.json');\n  return `animation-${animationName}`;\n}\nclass LottieTransferState {\n  constructor(transferState) {\n    this.transferState = transferState;\n  }\n  get(animation) {\n    const animationKey = transformAnimationFilenameToKey(animation);\n    const stateKey = makeStateKey(animationKey);\n    return this.transferState.get(stateKey, null);\n  }\n  /** @nocollapse */\n  static {\n    this.ɵfac = function LottieTransferState_Factory(t) {\n      return new (t || LottieTransferState)(i0.ɵɵinject(i0.TransferState));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: LottieTransferState,\n      factory: LottieTransferState.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LottieTransferState, [{\n    type: Injectable,\n    args: [{\n      providedIn: 'root'\n    }]\n  }], () => [{\n    type: i0.TransferState\n  }], null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AnimationLoader, BaseDirective, LottieComponent, LottieDirective, LottieTransferState, provideCacheableAnimationLoader, provideLottieOptions, transformAnimationFilenameToKey, CacheableAnimationLoader as ɵCacheableAnimationLoader, LOTTIE_OPTIONS as ɵLOTTIE_OPTIONS };\n"],
  "mappings": "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",
  "names": ["player"]
}
